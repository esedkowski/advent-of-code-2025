import pylab as pl
from matplotlib import collections as mc
INPUT = "input"
TEST_INPUT = "test_input"
own = "own_input"

file = TEST_INPUT
file = INPUT
# file = own

def abs(number):
    return number if number >= 0 else number * (-1)

def get_data(file):
    tiles = []
    with open(file) as _input:
        for line in _input:
            x, y = line.split(",")
            tiles.append((int(x),int(y)))

    return tiles

def get_lines(tiles):
    h_lines = []
    v_lines = []
    for i in range (-1, len(tiles) - 1):
        t1 = tiles[i]
        t2 = tiles[i+1]
        if t1[0] == t2[0]:
            if t1[1] >= t2[1]:
                v_lines.append((t1[0], t2[1], t1[1]))
            else:
                v_lines.append((t1[0], t1[1], t2[1]))
        elif t1[1] == t2[1]:
            if t1[0] >= t2[0]:
                h_lines.append((t1[1], t2[0], t1[0]))
            else:
                h_lines.append((t1[1], t1[0], t2[0]))
        else:
            raise ValueError("line not in one axis")

    return h_lines, v_lines

def sort_lines(lines):
    num_of_lines = len(lines)
    if num_of_lines < 2:
        return lines

    half_of_lines = num_of_lines // 2
    half1 = sort_lines(lines[:half_of_lines])
    half2 = sort_lines(lines[half_of_lines:])

    sorted_lines = []
    while len(half1) > 0 and len(half2) > 0:
        if half1[0][0] < half2[0][0]:
            sorted_lines.append(half1.pop(0))
        else:
            sorted_lines.append(half2.pop(0))
    for i in range(len(half1)):
        sorted_lines.append(half1.pop(0))
    for i in range(len(half2)):
        sorted_lines.append(half2.pop(0))

    return(sorted_lines)

def is_on_edge(p, v_lines, h_lines):
    for v_line in v_lines:
        if p[1] == v_line[0] and (v_line[1] <= p[1] <= v_line[2]):
            return True
    for h_line in h_lines:
        if p[0] == h_line[0] and (h_line[1] <= p[0] <= h_line[2]):
            return True
    return False

"""
def is_inside(p, v_lines, h_lines):
    num_of_v_lines = len(v_lines)
    num_of_h_lines = len(h_lines)
    inside = False

    count = 0

    x = p[0]
    y = p[1]

    for v_line in v_lines:
        if x == v_line[0]:
            count += 1


    for i in range(num_of_v_lines - 1):
        v_line1 = v_lines[i]
        if (v_line1[1] <= p[1] <= v_line1[2]) and p[0] >= v_line1[0]:
            for j in range(i + 1, num_of_v_lines):
                v_line2 = v_lines[j]
                if (v_line2[1] <= p[1] <= v_line2[2]) and p[0] <= v_line2[0]:
                    inside = True
                    break

    if not inside:
        # print(p, False, "1")
        return False

    inside = False

    for i in range(num_of_h_lines - 1):
        h_line1 = h_lines[i]
        if (h_line1[1] <= p[0] <= h_line1[2]) and p[1] >= h_line1[0]:
            for j in range(i + 1, num_of_h_lines):
                h_line2 = h_lines[j]
                if (h_line2[1] <= p[0] <= h_line2[2]) and p[1] <= h_line2[0]:
                    inside = True
                    break
    # print(p, inside, "2")
    return inside
"""

def is_inside(p, tiles): # with huge help of chatgpt
    x, y = p
    inside = False
    n = len(tiles)
    count = 0

    for i in range(n - 1):
        x1, y1 = tiles[i]
        x2, y2 = tiles[(i + 1) % n]

        if (x == x1 and y == y1) or (x == x2 and y == y2):
            # print("test1")
            return True
        if y1 != y2:
            if ((y1 > y) != (y2 > y)) or y == max(y1, y2):
                print(x1, y1, x2, y2)
                if x < x1:
                    count += 1

    print(count)
    if count % 2 == 1:
        # print("test2")
        return True
    else:
        # print("test3")
        return False



def crosses_line(p1, p2, v_lines, h_lines):
    if p1[0] == p2[0]:
        x = p1[0]
        y1 = min(p1[1], p2[1])
        y2 = max(p1[1], p2[1])
        for h_line in h_lines:
            if (y1 < h_line[0] < y2) and (h_line[1] < x < h_line[2]):
                return True
            if y2 < h_line[0]:
                break
    if p1[1] == p2[1]:
        y = p1[1]
        x1 = min(p1[0], p2[0])
        x2 = max(p1[0], p2[0])
        for v_line in v_lines:
            if (x1 < v_line[0] < x2) and (v_line[1] < y < v_line[2]):
                return True
            if x2 < v_line[0]:
                break
    return False

def find_biggest_square(tiles, v_lines, h_lines):
    num_of_tiles = len(tiles)
    biggest_area = 0
    # print(v_lines, h_lines)
    for i in range(num_of_tiles):
        for j in range(i + 1, num_of_tiles):
            p1 = tiles[i]
            p2 = tiles[j]
            p3 = (p1[0], p2[1])
            p4 = (p2[0], p1[1])
            if is_inside(p3, tiles) and is_inside(p4, tiles):
                points = [p1, p2, p3, p4]
                valid = True
                for k in range(3):
                    for h in range(k + 1, 4):
                        if points[k][0] == points[h][0] or points[k][1] == points[h][1]:
                            valid = valid and not crosses_line(points[k], points[h], v_lines, h_lines)
                            # print(points[i], points[j], points, valid)
                if valid:
                    area = (abs(p2[0] - p1[0]) + 1) * (abs(p2[1] - p1[1]) + 1) # +1 to handle 'of by 1 error'
                    if area > biggest_area:
                        biggest_area = area
                        biggest_square = (p1, p2, biggest_area)

    return biggest_square



tiles = get_data(file)
is_inside((1874, 98081), tiles)
"""
h_lines, v_lines = get_lines(tiles)
h_lines = sort_lines(h_lines)
v_lines = sort_lines(v_lines)
biggest_square = find_biggest_square(tiles, v_lines, h_lines)
print(biggest_square[0], biggest_square[1], biggest_square[2])

xs = []
ys = []
count = 0
itin = []
fig, ax = pl.subplots()

for point in tiles:
    xs.append(point[0])
    ys.append(point[1])

lines = []
for i in range(-1, len(tiles) - 1):
    lines.append([tiles[i], tiles[i+1]])
lc = mc.LineCollection(lines, linewidth=2)
ax.add_collection(lc)

ax.margins(0.1)
# pl.scatter(xs, ys)

p1 = biggest_square[0]
p3 = biggest_square[1]
p2 = (p1[0], p3[1])
p4 = (p3[0], p1[1])

points = [p1, p2, p3, p4]
xs1 = []
ys1 = []

for point in points:
    xs1.append(point[0])
    ys1.append(point[1])

lines1 = []
for i in range(-1, 3):
    lines1.append([points[i], points[i+1]])
lc1 = mc.LineCollection(lines1, linewidth=2, colors='red')
ax.add_collection(lc1)

# pl.scatter(xs1, ys1)


pl.savefig("test.png")
pl.close()"""
